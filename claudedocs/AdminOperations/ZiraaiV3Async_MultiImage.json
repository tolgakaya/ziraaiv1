{
  "name": "ZiraaiV3Async_MultiImage",
  "nodes": [
    {
      "parameters": {
        "queue": "plant-analysis-multi-image-requests",
        "options": {
          "jsonParseBody": true,
          "onlyContent": true,
          "parallelMessages": 1
        }
      },
      "id": "c83bb147-7645-4052-acab-7e36380c2191",
      "name": "RabbitMQ Trigger",
      "type": "n8n-nodes-base.rabbitmqTrigger",
      "typeVersion": 1,
      "position": [
        -1440,
        80
      ],
      "credentials": {
        "rabbitmq": {
          "id": "XcozjPMKFWvxokup",
          "name": "RabbitMQ account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// PARSE RABBITMQ MESSAGE - MULTI-IMAGE SUPPORT\n// Supports up to 4 images:\n// 1. Main image (required) - imageUrl/image\n// 2. leaf_top_url - Yaprağın üst yüzeyi (optional)\n// 3. leaf_bottom_url - Yaprağın alt yüzeyi (optional)\n// 4. plant_overview_url - Bitkinin genel görünümü (optional)\n// 5. root_url - Kök resmi (optional)\n// ============================================\n\nconst item = $input.first();\nconst message = item.json;\n\nconsole.log('=== RABBITMQ MESSAGE RECEIVED =======================');\nconsole.log('Message keys:', Object.keys(message));\nconsole.log('Message type:', typeof message);\nconsole.log('Raw message preview:', JSON.stringify(message).substring(0, 300));\n\n// Helper function for case-insensitive field extraction\nfunction getFieldCaseInsensitive(obj, fieldName) {\n  // Try exact match first\n  if (obj[fieldName] !== undefined) return obj[fieldName];\n  \n  // Try case-insensitive match\n  const keys = Object.keys(obj);\n  const lowerFieldName = fieldName.toLowerCase();\n  \n  for (const key of keys) {\n    if (key.toLowerCase() === lowerFieldName) {\n      return obj[key];\n    }\n  }\n  \n  return null;\n}\n\n// Extract message data - handle different message formats\nlet messageData;\n\n// RabbitMQ'dan gelen mesajlar farklı formatlarda olabilir\nif (typeof message === 'string') {\n  // Eğer direkt string ise parse et\n  try {\n    messageData = JSON.parse(message);\n    console.log('Parsed message from direct string');\n  } catch (e) {\n    console.error('Failed to parse message as JSON:', e.message);\n    throw new Error('Invalid JSON in message');\n  }\n} else if (Array.isArray(message)) {\n  // If message is an array, take the first element\n  messageData = message[0];\n  console.log('Using first element from array message');\n} else if (message.content) {\n  // If message has content field, parse it\n  if (typeof message.content === 'string') {\n    try {\n      messageData = JSON.parse(message.content);\n      console.log('Parsed message from content string');\n    } catch (e) {\n      console.error('Failed to parse content as JSON:', e.message);\n      throw new Error('Invalid JSON in message content');\n    }\n  } else {\n    messageData = message.content;\n    console.log('Using content object directly');\n  }\n} else {\n  // Direct message format (already an object)\n  messageData = message;\n  console.log('Using direct message format');\n}\n\nconsole.log('Parsed message data keys:', Object.keys(messageData));\nconsole.log('Sample data:', JSON.stringify(messageData).substring(0, 200));\n\n// ============================================\n// VALIDATE AND EXTRACT IMAGES (URL or BASE64)\n// ============================================\n\n// Helper function to process image (URL or base64)\nfunction processImage(imageInput, fieldName) {\n  if (!imageInput || (typeof imageInput === 'string' && imageInput.trim() === '')) {\n    return null;\n  }\n  \n  let processedImage = imageInput;\n  let metadata = {};\n  \n  if (imageInput.startsWith('http://') || imageInput.startsWith('https://')) {\n    // URL format\n    metadata = {\n      format: 'url',\n      url: imageInput,\n      size_bytes: null,\n      size_kb: null,\n      size_mb: null,\n      base64_length: null\n    };\n  } else if (imageInput.startsWith('data:image/')) {\n    // Already data URI format\n    processedImage = imageInput;\n    const imageMatch = imageInput.match(/^data:image\\/(\\w+);base64,(.+)/);\n    if (imageMatch) {\n      const imageType = imageMatch[1];\n      const base64Data = imageMatch[2];\n      const imageSizeBytes = (base64Data.length * 0.75);\n      metadata = {\n        format: `image/${imageType}`,\n        size_bytes: imageSizeBytes,\n        size_kb: parseFloat((imageSizeBytes / 1024).toFixed(2)),\n        size_mb: parseFloat((imageSizeBytes / (1024 * 1024)).toFixed(2)),\n        base64_length: base64Data.length\n      };\n    }\n  } else {\n    // Raw base64, add prefix\n    processedImage = `data:image/jpeg;base64,${imageInput}`;\n    const imageSizeBytes = (imageInput.length * 0.75);\n    metadata = {\n      format: 'image/jpeg',\n      size_bytes: imageSizeBytes,\n      size_kb: parseFloat((imageSizeBytes / 1024).toFixed(2)),\n      size_mb: parseFloat((imageSizeBytes / (1024 * 1024)).toFixed(2)),\n      base64_length: imageInput.length\n    };\n  }\n  \n  console.log(`${fieldName}: processed successfully`);\n  return { image: processedImage, metadata: metadata };\n}\n\n// Extract MAIN image (required) - backward compatible\nconst mainImageUrl = getFieldCaseInsensitive(messageData, 'ImageUrl') || \n                    getFieldCaseInsensitive(messageData, 'image_url') || \n                    null;\n\nconst mainImageBase64 = getFieldCaseInsensitive(messageData, 'Image') || \n                       getFieldCaseInsensitive(messageData, 'image') || \n                       getFieldCaseInsensitive(messageData, 'image_base64') || \n                       null;\n\n// Extract OPTIONAL additional images\nconst leafTopInput = getFieldCaseInsensitive(messageData, 'LeafTopUrl') || \n                    getFieldCaseInsensitive(messageData, 'leaf_top_url') || \n                    getFieldCaseInsensitive(messageData, 'LeafTop') || \n                    getFieldCaseInsensitive(messageData, 'leaf_top') || \n                    null;\n\nconst leafBottomInput = getFieldCaseInsensitive(messageData, 'LeafBottomUrl') || \n                       getFieldCaseInsensitive(messageData, 'leaf_bottom_url') || \n                       getFieldCaseInsensitive(messageData, 'LeafBottom') || \n                       getFieldCaseInsensitive(messageData, 'leaf_bottom') || \n                       null;\n\nconst plantOverviewInput = getFieldCaseInsensitive(messageData, 'PlantOverviewUrl') || \n                          getFieldCaseInsensitive(messageData, 'plant_overview_url') || \n                          getFieldCaseInsensitive(messageData, 'PlantOverview') || \n                          getFieldCaseInsensitive(messageData, 'plant_overview') || \n                          null;\n\nconst rootInput = getFieldCaseInsensitive(messageData, 'RootUrl') || \n                 getFieldCaseInsensitive(messageData, 'root_url') || \n                 getFieldCaseInsensitive(messageData, 'Root') || \n                 getFieldCaseInsensitive(messageData, 'root') || \n                 null;\n\n// Process main image\nlet finalImage;\nlet imageMetadata = {};\n\nif (mainImageUrl && mainImageUrl.trim() !== '') {\n  const result = processImage(mainImageUrl, 'main_image_url');\n  if (result) {\n    finalImage = result.image;\n    imageMetadata = result.metadata;\n  }\n} else if (mainImageBase64 && mainImageBase64.trim() !== '') {\n  const result = processImage(mainImageBase64, 'main_image_base64');\n  if (result) {\n    finalImage = result.image;\n    imageMetadata = result.metadata;\n  }\n}\n\n// Process optional images\nconst leafTopResult = leafTopInput ? processImage(leafTopInput, 'leaf_top') : null;\nconst leafBottomResult = leafBottomInput ? processImage(leafBottomInput, 'leaf_bottom') : null;\nconst plantOverviewResult = plantOverviewInput ? processImage(plantOverviewInput, 'plant_overview') : null;\nconst rootResult = rootInput ? processImage(rootInput, 'root') : null;\n\n// If no main image but we have optional images, use first available as main\nif (!finalImage) {\n  if (leafTopResult) {\n    finalImage = leafTopResult.image;\n    imageMetadata = leafTopResult.metadata;\n    console.log('Using leaf_top as main image');\n  } else if (leafBottomResult) {\n    finalImage = leafBottomResult.image;\n    imageMetadata = leafBottomResult.metadata;\n    console.log('Using leaf_bottom as main image');\n  } else if (plantOverviewResult) {\n    finalImage = plantOverviewResult.image;\n    imageMetadata = plantOverviewResult.metadata;\n    console.log('Using plant_overview as main image');\n  } else if (rootResult) {\n    finalImage = rootResult.image;\n    imageMetadata = rootResult.metadata;\n    console.log('Using root as main image');\n  }\n}\n\nif (!finalImage) {\n  console.error('ERROR: No image found!');\n  console.error('Available keys in message:', Object.keys(messageData));\n  throw new Error('At least one image is required. Available fields: ' + Object.keys(messageData).join(', '));\n}\n\n// Count provided images\nconst providedImages = [\n  { name: 'main', image: finalImage },\n  { name: 'leaf_top', image: leafTopResult?.image },\n  { name: 'leaf_bottom', image: leafBottomResult?.image },\n  { name: 'plant_overview', image: plantOverviewResult?.image },\n  { name: 'root', image: rootResult?.image }\n].filter(img => img.image);\n\nconsole.log(`Total images provided: ${providedImages.length}`);\nprovidedImages.forEach(img => console.log(`  - ${img.name}: available`));\n\n// Add multi-image info to metadata\nimageMetadata.upload_timestamp = new Date().toISOString();\nimageMetadata.total_images = providedImages.length;\nimageMetadata.images_provided = providedImages.map(img => img.name);\nimageMetadata.has_leaf_top = !!leafTopResult;\nimageMetadata.has_leaf_bottom = !!leafBottomResult;\nimageMetadata.has_plant_overview = !!plantOverviewResult;\nimageMetadata.has_root = !!rootResult;\n\n// ============================================\n// EXTRACT ALL FIELDS (CASE-INSENSITIVE)\n// ============================================\n\n// User identification fields\nconst farmer_id = getFieldCaseInsensitive(messageData, 'FarmerId') || \n                 getFieldCaseInsensitive(messageData, 'farmer_id') || null;\nconst sponsor_id = getFieldCaseInsensitive(messageData, 'SponsorId') || \n                  getFieldCaseInsensitive(messageData, 'sponsor_id') || null;\nconst user_id = getFieldCaseInsensitive(messageData, 'UserId') || \n               getFieldCaseInsensitive(messageData, 'user_id') || null;\n\n// Location and environmental data\nconst location = getFieldCaseInsensitive(messageData, 'Location') || \n                getFieldCaseInsensitive(messageData, 'location') || null;\n\n// Handle GPS coordinates - can be object or string\nlet gps_coordinates = getFieldCaseInsensitive(messageData, 'GpsCoordinates') || \n                     getFieldCaseInsensitive(messageData, 'gps_coordinates') || null;\n\n// Convert GPS object to string format if needed\nif (gps_coordinates && typeof gps_coordinates === 'object') {\n  const lat = gps_coordinates.Lat || gps_coordinates.lat || 0;\n  const lng = gps_coordinates.Lng || gps_coordinates.lng || gps_coordinates.lon || 0;\n  gps_coordinates = `${lat},${lng}`;\n}\n\nconst altitude = getFieldCaseInsensitive(messageData, 'Altitude') || \n                getFieldCaseInsensitive(messageData, 'altitude') || null;\n\n// Field and crop information\nconst field_id = getFieldCaseInsensitive(messageData, 'FieldId') || \n                getFieldCaseInsensitive(messageData, 'field_id') || null;\nconst crop_type = getFieldCaseInsensitive(messageData, 'CropType') || \n                 getFieldCaseInsensitive(messageData, 'crop_type') || null;\nconst planting_date = getFieldCaseInsensitive(messageData, 'PlantingDate') || \n                     getFieldCaseInsensitive(messageData, 'planting_date') || null;\nconst expected_harvest_date = getFieldCaseInsensitive(messageData, 'ExpectedHarvestDate') || \n                             getFieldCaseInsensitive(messageData, 'expected_harvest_date') || null;\n\n// Agricultural practices\nconst last_fertilization = getFieldCaseInsensitive(messageData, 'LastFertilization') || \n                          getFieldCaseInsensitive(messageData, 'last_fertilization') || null;\nconst last_irrigation = getFieldCaseInsensitive(messageData, 'LastIrrigation') || \n                       getFieldCaseInsensitive(messageData, 'last_irrigation') || null;\nconst previous_treatments = getFieldCaseInsensitive(messageData, 'PreviousTreatments') || \n                           getFieldCaseInsensitive(messageData, 'previous_treatments') || [];\n\n// Environmental conditions\nconst weather_conditions = getFieldCaseInsensitive(messageData, 'WeatherConditions') || \n                          getFieldCaseInsensitive(messageData, 'weather_conditions') || null;\nconst temperature = getFieldCaseInsensitive(messageData, 'Temperature') || \n                   getFieldCaseInsensitive(messageData, 'temperature') || null;\nconst humidity = getFieldCaseInsensitive(messageData, 'Humidity') || \n                getFieldCaseInsensitive(messageData, 'humidity') || null;\nconst soil_type = getFieldCaseInsensitive(messageData, 'SoilType') || \n                 getFieldCaseInsensitive(messageData, 'soil_type') || null;\n\n// Additional fields\nconst urgency_level = getFieldCaseInsensitive(messageData, 'UrgencyLevel') || \n                     getFieldCaseInsensitive(messageData, 'urgency_level') || 'normal';\nconst notes = getFieldCaseInsensitive(messageData, 'Notes') || \n             getFieldCaseInsensitive(messageData, 'notes') || null;\n\n// Handle contact info - can be object or string\nlet contact_info = getFieldCaseInsensitive(messageData, 'ContactInfo') || \n                  getFieldCaseInsensitive(messageData, 'contact_info') || null;\n\n// Ensure contact_info is properly formatted\nif (contact_info && typeof contact_info === 'object') {\n  contact_info = {\n    phone: contact_info.Phone || contact_info.phone || null,\n    email: contact_info.Email || contact_info.email || null\n  };\n}\n\n// Handle additional info\nlet additional_info = getFieldCaseInsensitive(messageData, 'AdditionalInfo') || \n                     getFieldCaseInsensitive(messageData, 'additional_info') || {};\n\n// Ensure additional_info is properly formatted\nif (additional_info && typeof additional_info === 'object') {\n  additional_info = {\n    irrigation_method: additional_info.IrrigationMethod || additional_info.irrigation_method || null,\n    greenhouse: additional_info.Greenhouse !== undefined ? additional_info.Greenhouse : \n               (additional_info.greenhouse !== undefined ? additional_info.greenhouse : null),\n    organic_certified: additional_info.OrganicCertified !== undefined ? additional_info.OrganicCertified : \n                      (additional_info.organic_certified !== undefined ? additional_info.organic_certified : null)\n  };\n}\n\n// RabbitMQ specific fields\nconst correlation_id = getFieldCaseInsensitive(messageData, 'CorrelationId') || \n                      getFieldCaseInsensitive(messageData, 'correlation_id') || null;\nconst analysis_id = getFieldCaseInsensitive(messageData, 'AnalysisId') || \n                   getFieldCaseInsensitive(messageData, 'analysis_id') || null;\nconst response_queue = (getFieldCaseInsensitive(messageData, 'ResponseQueue') || \n                       getFieldCaseInsensitive(messageData, 'response_queue') || \n                       'plant-analysis-results').trim();\nconst callback_url = getFieldCaseInsensitive(messageData, 'CallbackUrl') || \n                    getFieldCaseInsensitive(messageData, 'callback_url') || null;\nconst priority = getFieldCaseInsensitive(messageData, 'Priority') || \n                getFieldCaseInsensitive(messageData, 'priority') || 'normal';\nconst retry_count = getFieldCaseInsensitive(messageData, 'RetryCount') || \n                   getFieldCaseInsensitive(messageData, 'retry_count') || 0;\n\n// Generate unique analysis ID if not provided\nconst timestamp = new Date().toISOString();\nconst randomId = Math.random().toString(36).substring(2, 11);\nconst final_analysis_id = analysis_id || \n                         `analysis_${Date.now()}_${farmer_id || 'anonymous'}_${randomId}`;\n\n// ============================================\n// PREPARE COMPLETE ANALYSIS DATA\n// ============================================\n\nconst analysisData = {\n  // Core fields\n  analysis_id: final_analysis_id,\n  timestamp: timestamp,\n  image: finalImage,\n  \n  // Multi-image fields (for prompt access)\n  leaf_top_image: leafTopResult?.image || null,\n  leaf_bottom_image: leafBottomResult?.image || null,\n  plant_overview_image: plantOverviewResult?.image || null,\n  root_image: rootResult?.image || null,\n  \n  // User identification\n  user_id: user_id,\n  farmer_id: farmer_id,\n  sponsor_id: sponsor_id,\n  \n  // Location data\n  location: location,\n  gps_coordinates: gps_coordinates,\n  altitude: altitude,\n  \n  // Field and crop information\n  field_id: field_id,\n  crop_type: crop_type,\n  planting_date: planting_date,\n  expected_harvest_date: expected_harvest_date,\n  \n  // Agricultural practices\n  last_fertilization: last_fertilization,\n  last_irrigation: last_irrigation,\n  previous_treatments: previous_treatments,\n  \n  // Environmental conditions\n  weather_conditions: weather_conditions,\n  temperature: temperature,\n  humidity: humidity,\n  soil_type: soil_type,\n  \n  // Additional information\n  urgency_level: urgency_level,\n  notes: notes,\n  contact_info: contact_info,\n  additional_info: additional_info,\n  \n  // Image metadata\n  image_metadata: imageMetadata,\n  \n  // RabbitMQ specific metadata\n  rabbitmq_metadata: {\n    correlation_id: correlation_id,\n    response_queue: response_queue.trim(),\n    callback_url: callback_url,\n    priority: priority,\n    retry_count: retry_count,\n    received_at: timestamp,\n    message_id: message.messageId || null,\n    routing_key: message.routingKey || null\n  }\n};\n\n// ============================================\n// LOG PROCESSING START\n// ============================================\n\nconsole.log('=== PROCESSING PLANT ANALYSIS =======================');\nconsole.log(`Analysis ID: ${final_analysis_id}`);\nconsole.log(`User ID: ${user_id || 'Not provided'}`);\nconsole.log(`Farmer ID: ${farmer_id || 'Not provided'}`);\nconsole.log(`Sponsor ID: ${sponsor_id || 'Not provided'}`);\nconsole.log(`Location: ${location || 'Not provided'}`);\nconsole.log(`GPS Coordinates: ${gps_coordinates || 'Not provided'}`);\nconsole.log(`Crop Type: ${crop_type || 'Not provided'}`);\nconsole.log(`Priority: ${priority}`);\nconsole.log(`Response Queue: ${response_queue}`);\nconsole.log(`Total Images: ${providedImages.length}`);\nconsole.log(`  - Main Image: Available`);\nconsole.log(`  - Leaf Top: ${leafTopResult ? 'Available' : 'Not provided'}`);\nconsole.log(`  - Leaf Bottom: ${leafBottomResult ? 'Available' : 'Not provided'}`);\nconsole.log(`  - Plant Overview: ${plantOverviewResult ? 'Available' : 'Not provided'}`);\nconsole.log(`  - Root: ${rootResult ? 'Available' : 'Not provided'}`);\nconsole.log('====================================================');\n\nreturn {\n  json: analysisData\n};"
      },
      "id": "6e73b769-945a-4e60-9f41-36ccd8042dc4",
      "name": "Parse and Validate RabbitMQ Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1232,
        80
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are an expert agricultural analyst with deep knowledge in plant pathology, nutrition (macro and micro elements), pest management, physiological disorders, soil science, and environmental stress factors.\n\nYour task is to analyze the provided plant image(s) comprehensively and return a structured JSON report.\n\n============================================\nMULTI-IMAGE ANALYSIS (if additional images provided)\n============================================\n\nYou may receive UP TO 4 DIFFERENT IMAGES of the same plant. Analyze all provided images together for a more comprehensive diagnosis:\n\n**MAIN IMAGE:** {{ $json.image }}\nThis is the primary image for analysis.\n\n{{$json.leaf_top_image ? '**LEAF TOP IMAGE (Yaprağın Üst Yüzeyi):** ' + $json.leaf_top_image + '\\nFocus on: Upper leaf surface symptoms, color variations, spots, lesions, powdery mildew, rust, insect feeding damage, nutrient deficiency patterns (interveinal chlorosis, etc.)\\n' : ''}}\n{{$json.leaf_bottom_image ? '**LEAF BOTTOM IMAGE (Yaprağın Alt Yüzeyi):** ' + $json.leaf_bottom_image + '\\nFocus on: Aphid colonies, whiteflies and eggs, spider mites and webs, downy mildew spores, rust pustules, scale insects, stomatal abnormalities\\n' : ''}}\n{{$json.plant_overview_image ? '**PLANT OVERVIEW IMAGE (Bitkinin Genel Görünümü):** ' + $json.plant_overview_image + '\\nFocus on: Overall plant vigor, stunting, wilting patterns, vascular wilt symptoms (one-sided wilting), stem structure, branching pattern, fruit/flower status\\n' : ''}}\n{{$json.root_image ? '**ROOT IMAGE (Kök Resmi):** ' + $json.root_image + '\\nFocus on: Root color (healthy white vs brown/black rotted), root-knot nematode galling, root rot lesions, root development, fibrous root density, soil-borne disease symptoms\\n' : ''}}\n\n**MULTI-IMAGE ANALYSIS INSTRUCTIONS:**\n- Analyze ALL provided images together for comprehensive diagnosis\n- Cross-reference findings between images to confirm or rule out issues\n- If symptoms appear in multiple images, this increases diagnostic confidence\n- Note any contradictions between different image observations\n- If only the main image is provided, base your analysis solely on it\n- Total images provided: {{$json.image_metadata.total_images}}\n- Available images: {{$json.image_metadata.images_provided.join(', ')}}\n\n============================================\nIMPORTANT INSTRUCTIONS\n============================================\n\nAll JSON keys must remain in English exactly as provided.\n\nAll values must be written in Turkish (e.g., species name, disease description, nutrient status, stress factors, recommendations, summaries, etc.).\n\nDo not mix languages: keys stay in English, values are always Turkish.\n\nAlways:\n\nCross-check visible symptoms with provided environmental, soil, and treatment data.\n\nDistinguish between biotic (pests, diseases) and abiotic (nutrient, environmental, physiological) stress.\n\nProvide confidence scores (0–100) for each major detection.\n\nIf information is insufficient or ambiguous, explicitly state uncertainty and suggest what extra farmer input is needed (in Turkish).\n\nAdapt recommendations to regional conditions if location data is available.\n\nInclude both scientific explanations and a plain farmer-friendly summary in Turkish.\n\nProvide organic and chemical management options where relevant.\n\nCONTEXT INFORMATION PROVIDED:\n\nAnalysis ID: {{$json.analysis_id}}\n\nFarmer ID: {{$json.farmer_id || 'Not provided'}}\n\nLocation: {{$json.location || 'Not provided'}}\n\nGPS Coordinates: {{$json.gps_coordinates ? JSON.stringify($json.gps_coordinates) : 'Not provided'}}\n\nAltitude: {{$json.altitude || 'Not provided'}} meters\n\nField ID: {{$json.field_id || 'Not provided'}}\n\nCrop Type: {{$json.crop_type || 'Not provided'}}\n\nPlanting Date: {{$json.planting_date || 'Not provided'}}\n\nExpected Harvest: {{$json.expected_harvest_date || 'Not provided'}}\n\nSoil Type: {{$json.soil_type || 'Not provided'}}\n\nLast Fertilization: {{$json.last_fertilization || 'Not provided'}}\n\nLast Irrigation: {{$json.last_irrigation || 'Not provided'}}\n\nWeather Conditions: {{$json.weather_conditions || 'Not provided'}}\n\nTemperature: {{$json.temperature || 'Not provided'}}°C\n\nHumidity: {{$json.humidity || 'Not provided'}}%\n\nPrevious Treatments: {{$json.previous_treatments.length > 0 ? JSON.stringify($json.previous_treatments) : 'None'}}\n\nUrgency Level: {{$json.urgency_level}}\n\nNotes from Farmer: {{$json.notes || 'None'}}\n\nPerform a complete analysis covering ALL of the following aspects:\n\n(analysis categories same as before, but values must be produced in Turkish)\n\nAnalyze this image: {{ $json.image }}\n\nReturn ONLY a valid JSON object with this EXACT structure (no additional text):\n\n{\n  \"plant_identification\": {\n    \"species\": \"Türkçe değer\",\n    \"variety\": \"Türkçe değer veya bilinmiyor\",\n    \"growth_stage\": \"fide|vejetatif|çiçeklenme|meyve\",\n    \"confidence\": 0-100,\n    \"identifying_features\": [\"özellik1\", \"özellik2\"],\n    \"visible_parts\": [\"yapraklar\", \"gövde\", \"çiçekler\", \"meyveler\", \"kökler\"]\n  },\n  \"health_assessment\": {\n    \"vigor_score\": 1-10,\n    \"leaf_color\": \"Türkçe açıklama\",\n    \"leaf_texture\": \"Türkçe açıklama\",\n    \"growth_pattern\": \"normal|anormal - detay\",\n    \"structural_integrity\": \"sağlam|orta|zayıf - detay\",\n    \"stress_indicators\": [\"belirti1\", \"belirti2\"],\n    \"disease_symptoms\": [\"belirti1\", \"belirti2\"],\n    \"severity\": \"yok|düşük|orta|yüksek|kritik\"\n  },\n  \"nutrient_status\": {\n    \"nitrogen\": \"normal|eksik|fazla\",\n    \"phosphorus\": \"normal|eksik|fazla\",\n    \"potassium\": \"normal|eksik|fazla\",\n    \"calcium\": \"normal|eksik|fazla\",\n    \"magnesium\": \"normal|eksik|fazla\",\n    \"sulfur\": \"normal|eksik|fazla\",\n    \"iron\": \"normal|eksik|fazla\",\n    \"zinc\": \"normal|eksik|fazla\",\n    \"manganese\": \"normal|eksik|fazla\",\n    \"boron\": \"normal|eksik|fazla\",\n    \"copper\": \"normal|eksik|fazla\",\n    \"molybdenum\": \"normal|eksik|fazla\",\n    \"chlorine\": \"normal|eksik|fazla\",\n    \"nickel\": \"normal|eksik|fazla\",\n    \"primary_deficiency\": \"ana eksiklik veya yok\",\n    \"secondary_deficiencies\": [\"eksiklik1\", \"eksiklik2\"],\n    \"severity\": \"yok|düşük|orta|yüksek|kritik\"\n  },\n  \"pest_disease\": {\n    \"pests_detected\": [\n      {\"type\": \"zararlı adı\", \"group\": \"böcek|akar|nematod|kemirgen|diğer\", \"severity\": \"düşük|orta|yüksek\", \"confidence\": 0-100, \"location\": \"bitkinin bölgesi\"}\n    ],\n    \"diseases_detected\": [\n      {\"type\": \"hastalık adı\", \"category\": \"fungal|bakteriyel|viral|fizyolojik\", \"severity\": \"düşük|orta|yüksek\", \"affected_parts\": [\"etkilenen kısımlar\"], \"confidence\": 0-100}\n    ],\n    \"damage_pattern\": \"zarar deseni açıklaması\",\n    \"affected_area_percentage\": 0-100,\n    \"spread_risk\": \"yok|düşük|orta|yüksek\",\n    \"primary_issue\": \"ana sorun veya yok\"\n  },\n  \"environmental_stress\": {\n    \"water_status\": \"optimal|hafif kurak|kurak|hafif fazla|su baskını\",\n    \"temperature_stress\": \"yok|hafif sıcak|aşırı sıcak|hafif soğuk|aşırı soğuk\",\n    \"light_stress\": \"yok|yetersiz|aşırı\",\n    \"physical_damage\": \"yok|rüzgar|dolu|mekanik|hayvan\",\n    \"chemical_damage\": \"yok|şüpheli|kesin - detay\",\n    \"physiological_disorders\": [\n      {\"type\": \"güneş yanığı|tuz zararı|don zararı|herbisit zararı|besin toksisitesi\", \"severity\": \"düşük|orta|yüksek\", \"notes\": \"detaylar\"}\n    ],\n    \"soil_health_indicators\": {\n      \"salinity\": \"yok|hafif|orta|şiddetli\",\n      \"pH_issue\": \"asidik|alkali|optimal\",\n      \"organic_matter\": \"düşük|orta|yüksek\"\n    },\n    \"primary_stressor\": \"ana stres faktörü veya yok\"\n  },\n  \"cross_factor_insights\": [\n    {\n      \"insight\": \"faktörler arası ilişki açıklaması\",\n      \"confidence\": 0.0-1.0,\n      \"affected_aspects\": [\"alan1\", \"alan2\"],\n      \"impact_level\": \"düşük|orta|yüksek\"\n    }\n  ],\n  \"risk_assessment\": {\n    \"yield_loss_probability\": \"düşük|orta|yüksek\",\n    \"timeline_to_worsen\": \"gün|hafta\",\n    \"spread_potential\": \"yok|lokal|tarlanın geneli\"\n  },\n  \"recommendations\": {\n    \"immediate\": [\n      {\"action\": \"ne yapılmalı\", \"details\": \"özel talimat\", \"timeline\": \"X saat içinde\", \"priority\": \"kritik|yüksek|orta\"}\n    ],\n    \"short_term\": [\n      {\"action\": \"ne yapılmalı\", \"details\": \"özel talimat\", \"timeline\": \"X-Y gün\", \"priority\": \"yüksek|orta|düşük\"}\n    ],\n    \"preventive\": [\n      {\"action\": \"önlem\", \"details\": \"özel talimat\", \"timeline\": \"sürekli\", \"priority\": \"orta|düşük\"}\n    ],\n    \"monitoring\": [\n      {\"parameter\": \"izlenecek parametre\", \"frequency\": \"sıklık\", \"threshold\": \"tetikleyici eşik\"}\n    ],\n    \"resource_estimation\": {\n      \"water_required_liters\": \"litre cinsinden\",\n      \"fertilizer_cost_estimate_usd\": \"maliyet $\",\n      \"labor_hours_estimate\": \"saat\"\n    },\n    \"localized_recommendations\": {\n      \"region\": \"bölge adı\",\n      \"preferred_practices\": [\"uygulama1\", \"uygulama2\"],\n      \"restricted_methods\": [\"yasaklı yöntem1\", \"yasaklı yöntem2\"]\n    }\n  },\n  \"summary\": {\n    \"overall_health_score\": 1-10,\n    \"primary_concern\": \"en kritik sorun\",\n    \"secondary_concerns\": [\"diğer önemli sorunlar\"],\n    \"critical_issues_count\": 0-N,\n    \"confidence_level\": 0-100,\n    \"prognosis\": \"mükemmel|iyi|orta|zayıf|kritik\",\n    \"estimated_yield_impact\": \"yok|minimal|orta|önemli|çok ciddi\"\n  },\n  \"confidence_notes\": [\n    {\"aspect\": \"nutrient_status\", \"confidence\": 0.85, \"reason\": \"Türkçe açıklama\"}\n  ],\n  \"farmer_friendly_summary\": \"Çiftçi için sade Türkçe açıklama.\"\n}\n",
        "options": {}
      },
      "id": "89b319bf-70a0-48bd-9fc4-4729f7ad4e86",
      "name": "Agricultural Analysis AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.6,
      "position": [
        -1040,
        80
      ]
    },
    {
      "parameters": {
        "queue": "plant-analysis-multi-image-results",
        "sendInputData": false,
        "message": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "id": "fc759f72-1837-490e-9937-3e7945c9ca01",
      "name": "Send to Response Queue",
      "type": "n8n-nodes-base.rabbitmq",
      "typeVersion": 1,
      "position": [
        -368,
        80
      ],
      "credentials": {
        "rabbitmq": {
          "id": "XcozjPMKFWvxokup",
          "name": "RabbitMQ account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.error }}",
              "value2": true
            }
          ]
        }
      },
      "id": "175fd3be-7a48-4a13-9a92-5a29866f5d0c",
      "name": "Check if Failed",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -208,
        80
      ]
    },
    {
      "parameters": {
        "queue": "plant-analysis-dlq ",
        "sendInputData": false,
        "message": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "id": "059788d0-5e90-46df-a23b-c150b7a340e3",
      "name": "Send to DLQ",
      "type": "n8n-nodes-base.rabbitmq",
      "typeVersion": 1,
      "position": [
        0,
        -16
      ],
      "credentials": {
        "rabbitmq": {
          "id": "XcozjPMKFWvxokup",
          "name": "RabbitMQ account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// LOG SUCCESSFUL ANALYSIS\n// ============================================\n\nconst item = $input.first();\n\nconsole.log('╔════════════════════════════════════════════════════╗');\nconsole.log('║        ANALYSIS COMPLETED SUCCESSFULLY             ║');\nconsole.log('╠════════════════════════════════════════════════════╣');\nconsole.log(`║ Analysis ID    : ${(item.json.analysis_id || 'N/A').toString().substring(0, 34).padEnd(34)} ║`);\nconsole.log(`║ Farmer ID      : ${(item.json.farmer_id || 'N/A').toString().substring(0, 34).padEnd(34)} ║`);\nconsole.log(`║ Sponsor ID     : ${(item.json.sponsor_id || 'N/A').toString().substring(0, 34).padEnd(34)} ║`);\nconsole.log(`║ Location       : ${(item.json.location || 'N/A').toString().substring(0, 34).padEnd(34)} ║`);\nconsole.log(`║ Crop Type      : ${(item.json.crop_type || 'N/A').toString().substring(0, 34).padEnd(34)} ║`);\nconsole.log(`║ Images Used    : ${(item.json.image_metadata?.total_images?.toString() || '1').padEnd(34)} ║`);\nconsole.log('╠════════════════════════════════════════════════════╣');\nconsole.log(`║ Health Score   : ${(item.json.summary?.overall_health_score + '/10' || 'N/A').padEnd(34)} ║`);\nconsole.log(`║ Primary Concern: ${(item.json.summary?.primary_concern || 'N/A').substring(0, 34).padEnd(34)} ║`);\nconsole.log(`║ Critical Issues: ${(item.json.summary?.critical_issues_count?.toString() || '0').padEnd(34)} ║`);\nconsole.log(`║ Confidence     : ${(item.json.summary?.confidence_level + '%' || 'N/A').padEnd(34)} ║`);\nconsole.log('╠════════════════════════════════════════════════════╣');\nconsole.log(`║ Processing Time: ${(item.json.processing_metadata?.processing_time_ms + 'ms' || 'N/A').padEnd(34)} ║`);\nconsole.log(`║ Response Queue : ${(item.json.rabbitmq_metadata?.response_queue || 'N/A').substring(0, 34).padEnd(34)} ║`);\nconsole.log('╚════════════════════════════════════════════════════╝');\n\n// If callback URL exists, you might want to trigger a webhook here\nif (item.json.rabbitmq_metadata?.callback_url) {\n  console.log(`Callback URL configured: ${item.json.rabbitmq_metadata.callback_url}`);\n  // Add HTTP Request node after this if you want to send callbacks\n}\n\nreturn item;"
      },
      "id": "b47014d0-d1bd-43cb-96f1-5526dbd4aed1",
      "name": "Log Success",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16,
        208
      ]
    },
    {
      "parameters": {
        "model": "gpt-5-mini",
        "options": {}
      },
      "id": "0b86e94b-04fb-4b03-9ec6-0fd9954a22b3",
      "name": "OpenAI GPT-5-mini",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [
        -1040,
        240
      ],
      "credentials": {
        "openAiApi": {
          "id": "7Bq6WUwi2SozC5r8",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// TOKEN USAGE CALCULATOR & COST ESTIMATOR - MULTI-IMAGE VERSION\n// (Updated for new pricing: Input $0.250/M, Cached Input $0.025/M, Output $2.000/M)\n// ============================================\n\nconst item = $input.first();\n\n// Pull data from the PREVIOUS node (before AI Agent)\nconst previousNodeData = $items('Parse and Validate RabbitMQ Message')[0].json ?? {};\n\nconsole.log('=== TOKEN CALCULATOR DEBUG ==========================');\nconsole.log('Current item keys:', Object.keys(item.json || {}));\nconsole.log('Previous node farmer_id:', previousNodeData.farmer_id);\nconsole.log('Previous node sponsor_id:', previousNodeData.sponsor_id);\nconsole.log('Previous node total_images:', previousNodeData.image_metadata?.total_images);\n\n// Preserve original fields (UNCHANGED from original)\nconst preservedData = {\n  analysis_id: previousNodeData.analysis_id,\n  timestamp: previousNodeData.timestamp,\n  farmer_id: previousNodeData.farmer_id,\n  sponsor_id: previousNodeData.sponsor_id,\n  location: previousNodeData.location,\n  gps_coordinates: previousNodeData.gps_coordinates,\n  altitude: previousNodeData.altitude,\n  field_id: previousNodeData.field_id,\n  crop_type: previousNodeData.crop_type,\n  planting_date: previousNodeData.planting_date,\n  expected_harvest_date: previousNodeData.expected_harvest_date,\n  last_fertilization: previousNodeData.last_fertilization,\n  last_irrigation: previousNodeData.last_irrigation,\n  previous_treatments: previousNodeData.previous_treatments,\n  weather_conditions: previousNodeData.weather_conditions,\n  temperature: previousNodeData.temperature,\n  humidity: previousNodeData.humidity,\n  soil_type: previousNodeData.soil_type,\n  urgency_level: previousNodeData.urgency_level,\n  notes: previousNodeData.notes,\n  contact_info: previousNodeData.contact_info,\n  additional_info: previousNodeData.additional_info,\n  image_url: previousNodeData.image_url,\n  image_metadata: previousNodeData.image_metadata,\n  request_metadata: previousNodeData.request_metadata,\n  rabbitmq_metadata: previousNodeData.rabbitmq_metadata\n};\n\nconsole.log('=== TOKEN CALCULATOR - PRESERVED DATA ===============');\nconsole.log(`Farmer ID preserved: ${preservedData.farmer_id}`);\nconsole.log(`Sponsor ID preserved: ${preservedData.sponsor_id}`);\nconsole.log(`Total Images: ${preservedData.image_metadata?.total_images || 1}`);\n\n// Agent output\nconst agentOutput =\n  item.json.output ||\n  item.json.response ||\n  item.json.content ||\n  item.json.text ||\n  \"\";\n\n// ------- Token estimation helpers -------\nfunction estimateTokens(text) {\n  if (!text) return 0;\n  const words = text.split(/\\s+/).filter(Boolean).length;\n  const chars = text.length;\n  const byWords = Math.ceil(words * 1.3);\n  const byChars = Math.ceil(chars / 4);\n  const byNewlines = (text.match(/\\n/g) || []).length * 0.5;\n  return Math.ceil((byWords + byChars) / 2 + byNewlines);\n}\n\nfunction estimateImageTokensFromUrl() {\n  // Heuristic for high-detail image analysis\n  return 765;\n}\n\nfunction estimateJSONTokens(obj) {\n  if (!obj) return 0;\n  try {\n    const jsonString = JSON.stringify(obj, null, 2);\n    return estimateTokens(jsonString);\n  } catch {\n    return 0;\n  }\n}\n\n// ------- Token calculation (updated for multi-image) -------\nconst systemPromptTokens = 250; // Slightly increased for multi-image instructions\n\nconst contextData = {\n  farmer_id: previousNodeData.farmer_id,\n  location: previousNodeData.location,\n  crop_type: previousNodeData.crop_type,\n  soil_type: previousNodeData.soil_type,\n  weather_conditions: previousNodeData.weather_conditions,\n  previous_treatments: previousNodeData.previous_treatments,\n  notes: previousNodeData.notes\n};\n\nconst contextTokens = estimateJSONTokens(contextData);\n\n// Calculate tokens for ALL provided images\nconst totalImages = previousNodeData.image_metadata?.total_images || 1;\nconst imageTokens = estimateImageTokensFromUrl() * totalImages;\n\nconst imageUrl = previousNodeData.image_url || \"\";\nconst imageUrlTokens = estimateTokens(imageUrl);\n\nlet inputTokens =\n  systemPromptTokens + contextTokens + imageTokens + imageUrlTokens;\n\nlet outputTokens = 0;\nif (agentOutput) {\n  outputTokens =\n    typeof agentOutput === 'string'\n      ? estimateTokens(agentOutput)\n      : estimateJSONTokens(agentOutput);\n}\n\n// ------- Cached input detection -------\nconst rm = previousNodeData.request_metadata || {};\nconst cachedInputTokens =\n  Number(rm.cached_input_tokens) ||\n  Number(rm.cache_hit_tokens) ||\n  Number(item.json.cached_input_tokens) ||\n  Number(item.json.cache_hit_tokens) ||\n  0;\n\nconst effectiveCachedInputTokens = Math.max(\n  0,\n  Math.min(cachedInputTokens, inputTokens)\n);\n\nconst regularInputTokens = Math.max(0, inputTokens - effectiveCachedInputTokens);\n\n// ------- Pricing (per 1,000,000 tokens) -------\nconst pricing = {\n  'gpt-5-mini': {\n    input_per_million: 0.250,\n    cached_input_per_million: 0.025,\n    output_per_million: 2.000\n  }\n};\n\nconst usedModel = 'gpt-5-mini';\nconst modelPricing = pricing[usedModel];\n\nif (!modelPricing) {\n  throw new Error(`Pricing not defined for model: ${usedModel}`);\n}\n\nconst perToken = {\n  input: modelPricing.input_per_million / 1_000_000,\n  cached_input: modelPricing.cached_input_per_million / 1_000_000,\n  output: modelPricing.output_per_million / 1_000_000\n};\n\n// ------- Cost calculation -------\nconst inputCostUSD = regularInputTokens * perToken.input;\nconst cachedInputCostUSD = effectiveCachedInputTokens * perToken.cached_input;\nconst outputCostUSD = outputTokens * perToken.output;\n\nconst totalCostUSD = inputCostUSD + cachedInputCostUSD + outputCostUSD;\n\nconst usdToTry =\n  Number(rm.usd_to_try) ||\n  Number(item.json.usd_to_try) ||\n  50;\n\nconst totalCostTRY = totalCostUSD * usdToTry;\n\n// ------- Token & cost report (structure unchanged) -------\nconst tokenReport = {\n  summary: {\n    model: usedModel,\n    analysis_id: previousNodeData.analysis_id,\n    timestamp: new Date().toISOString(),\n    total_tokens: inputTokens + outputTokens,\n    total_cost_usd: Number(totalCostUSD.toFixed(6)),\n    total_cost_try: Number(totalCostTRY.toFixed(4)),\n    image_source: 'url'\n  },\n  token_breakdown: {\n    input: {\n      system_prompt: systemPromptTokens,\n      context_data: contextTokens,\n      image: imageTokens,\n      image_url_text: imageUrlTokens,\n      cached_input_tokens: effectiveCachedInputTokens,\n      regular_input_tokens: regularInputTokens,\n      total: inputTokens\n    },\n    output: {\n      response: outputTokens,\n      total: outputTokens\n    },\n    grand_total: inputTokens + outputTokens\n  },\n  cost_breakdown: {\n    input_cost_usd: Number(inputCostUSD.toFixed(6)),\n    cached_input_cost_usd: Number(cachedInputCostUSD.toFixed(6)),\n    output_cost_usd: Number(outputCostUSD.toFixed(6)),\n    total_cost_usd: Number(totalCostUSD.toFixed(6)),\n    total_cost_try: Number(totalCostTRY.toFixed(4)),\n    exchange_rate: Number(usdToTry)\n  }\n};\n\nconsole.log(`Total Images: ${totalImages}`);\nconsole.log(`Total Tokens: ${inputTokens + outputTokens}`);\nconsole.log(`Cost USD: $${totalCostUSD.toFixed(6)} | TRY: ₺${totalCostTRY.toFixed(4)}`);\nconsole.log('================================================');\n\n// Combine everything (structure unchanged)\nconst outputData = {\n  ...preservedData,\n  output: agentOutput,\n  token_usage: tokenReport\n};\n\nconsole.log('=== FINAL OUTPUT CHECK ==========================');\nconsole.log(`Farmer ID in output: ${outputData.farmer_id}`);\nconsole.log(`Sponsor ID in output: ${outputData.sponsor_id}`);\nconsole.log('================================================');\n\nreturn [{ json: outputData }];\n"
      },
      "id": "f62d126b-bcdc-41f7-896d-7b47ea6511ff",
      "name": "Token Usage Calculator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -768,
        80
      ]
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// PARSE AND VALIDATE AI AGENT OUTPUT - MULTI-IMAGE VERSION\n// Output structure remains EXACTLY the same as original\n// ============================================\n\nconst item = $input.first();\n\n// Helper function to parse GPS coordinates\nfunction parseGpsCoordinates(gpsInput) {\n  if (!gpsInput) return null;\n  \n  // Already in object format\n  if (typeof gpsInput === 'object' && gpsInput !== null) {\n    return {\n      lat: parseFloat(gpsInput.lat || gpsInput.Lat || 0),\n      lng: parseFloat(gpsInput.lng || gpsInput.Lng || gpsInput.lon || gpsInput.Lon || 0)\n    };\n  }\n  \n  // String format: \"39.9334,32.8597\"\n  if (typeof gpsInput === 'string' && gpsInput.includes(',')) {\n    const parts = gpsInput.split(',').map(p => p.trim());\n    if (parts.length >= 2) {\n      const lat = parseFloat(parts[0]);\n      const lng = parseFloat(parts[1]);\n      if (!isNaN(lat) && !isNaN(lng)) {\n        return {\n          lat: lat,\n          lng: lng\n        };\n      }\n    }\n  }\n  \n  // Unable to parse, return null\n  return null;\n}\n\n// FIRST PRESERVE ALL INPUT FIELDS (UNCHANGED)\nconst preservedFields = {\n  analysis_id: item.json.analysis_id,\n  timestamp: item.json.timestamp,\n  farmer_id: item.json.farmer_id,\n  sponsor_id: item.json.sponsor_id,\n  location: item.json.location,\n  gps_coordinates: parseGpsCoordinates(item.json.gps_coordinates),  // Convert to object format\n  altitude: item.json.altitude,\n  field_id: item.json.field_id,\n  crop_type: item.json.crop_type,\n  planting_date: item.json.planting_date,\n  expected_harvest_date: item.json.expected_harvest_date,\n  last_fertilization: item.json.last_fertilization,\n  last_irrigation: item.json.last_irrigation,\n  previous_treatments: item.json.previous_treatments,\n  weather_conditions: item.json.weather_conditions,\n  temperature: item.json.temperature,\n  humidity: item.json.humidity,\n  soil_type: item.json.soil_type,\n  urgency_level: item.json.urgency_level,\n  notes: item.json.notes,\n  contact_info: item.json.contact_info,\n  additional_info: item.json.additional_info,\n  image_url: item.json.image_url,\n  image_metadata: item.json.image_metadata,\n  request_metadata: item.json.request_metadata,\n  rabbitmq_metadata: item.json.rabbitmq_metadata,\n  token_usage: item.json.token_usage\n};\n\nconsole.log('=== PARSE NODE - PRESERVED FIELDS ==================');\nconsole.log(`Farmer ID: ${preservedFields.farmer_id}`);\nconsole.log(`Sponsor ID: ${preservedFields.sponsor_id}`);\nconsole.log(`GPS Coordinates: ${JSON.stringify(preservedFields.gps_coordinates)}`);\nconsole.log(`Total Images: ${preservedFields.image_metadata?.total_images || 1}`);\n\nconst agentOutput = item.json.output || item.json.response || item.json.content || item.json.text || item.json.message || \"\";\n\nconsole.log(\"Raw output length:\", agentOutput.length);\nconsole.log(\"Output type:\", typeof agentOutput);\n\nlet analysis;\nlet parseSuccess = false;\n\ntry {\n  // Try to parse JSON from agent output\n  if (typeof agentOutput === 'string') {\n    let cleanedOutput = agentOutput;\n    cleanedOutput = cleanedOutput.replace(/```json\\n?/g, '');\n    cleanedOutput = cleanedOutput.replace(/```\\n?/g, '');\n    \n    const jsonStart = cleanedOutput.indexOf('{');\n    const jsonEnd = cleanedOutput.lastIndexOf('}') + 1;\n    \n    if (jsonStart !== -1 && jsonEnd !== 0) {\n      const jsonStr = cleanedOutput.substring(jsonStart, jsonEnd);\n      console.log(\"Extracted JSON length:\", jsonStr.length);\n      analysis = JSON.parse(jsonStr);\n      parseSuccess = true;\n      console.log(\"✓ JSON parsed successfully\");\n    } else {\n      throw new Error('No JSON structure found in response');\n    }\n  } else if (typeof agentOutput === 'object' && agentOutput !== null) {\n    analysis = agentOutput;\n    parseSuccess = true;\n    console.log(\"✓ Response already in object format\");\n  } else {\n    throw new Error('Invalid response format from AI agent');\n  }\n  \n  // MERGE WITH PRESERVED FIELDS - THIS IS CRITICAL\n  analysis = {\n    ...analysis,           // AI analysis results\n    ...preservedFields     // Override with all preserved fields\n  };\n  \n  // Validate required sections exist (UNCHANGED structure)\n  const requiredSections = [\n    'plant_identification',\n    'health_assessment',\n    'nutrient_status',\n    'pest_disease',\n    'environmental_stress',\n    'recommendations',\n    'summary'\n  ];\n  \n  for (const section of requiredSections) {\n    if (!analysis[section]) {\n      console.warn(`⚠ Missing section: ${section}, adding default`);\n      // Add default structures (UNCHANGED from original)\n      switch(section) {\n        case 'plant_identification':\n          analysis[section] = {\n            species: \"Unable to identify\",\n            variety: \"unknown\",\n            growth_stage: \"unknown\",\n            confidence: 0,\n            identifying_features: [],\n            visible_parts: []\n          };\n          break;\n        case 'health_assessment':\n          analysis[section] = {\n            vigor_score: 5,\n            leaf_color: \"Not analyzed\",\n            leaf_texture: \"Not analyzed\",\n            growth_pattern: \"Not analyzed\",\n            structural_integrity: \"Not analyzed\",\n            stress_indicators: [],\n            disease_symptoms: [],\n            severity: \"unknown\"\n          };\n          break;\n        case 'nutrient_status':\n          analysis[section] = {\n            nitrogen: \"unknown\",\n            phosphorus: \"unknown\",\n            potassium: \"unknown\",\n            calcium: \"unknown\",\n            magnesium: \"unknown\",\n            iron: \"unknown\",\n            primary_deficiency: \"none\",\n            secondary_deficiencies: [],\n            severity: \"unknown\"\n          };\n          break;\n        case 'pest_disease':\n          analysis[section] = {\n            pests_detected: [],\n            diseases_detected: [],\n            damage_pattern: \"Not analyzed\",\n            affected_area_percentage: 0,\n            spread_risk: \"unknown\",\n            primary_issue: \"none\"\n          };\n          break;\n        case 'environmental_stress':\n          analysis[section] = {\n            water_status: \"unknown\",\n            temperature_stress: \"unknown\",\n            light_stress: \"unknown\",\n            physical_damage: \"unknown\",\n            chemical_damage: \"unknown\",\n            soil_indicators: \"Not analyzed\",\n            primary_stressor: \"none\"\n          };\n          break;\n        case 'recommendations':\n          analysis[section] = {\n            immediate: [],\n            short_term: [],\n            preventive: [],\n            monitoring: []\n          };\n          break;\n        case 'summary':\n          analysis[section] = {\n            overall_health_score: 5,\n            primary_concern: \"Analysis incomplete\",\n            secondary_concerns: [],\n            critical_issues_count: 0,\n            confidence_level: 0,\n            prognosis: \"unknown\",\n            estimated_yield_impact: \"unknown\"\n          };\n          break;\n      }\n    }\n  }\n  \n  // Ensure arrays exist\n  analysis.cross_factor_insights = analysis.cross_factor_insights || [];\n  \n  // Add processing metadata (UNCHANGED structure)\n  analysis.processing_metadata = {\n    parse_success: parseSuccess,\n    processing_timestamp: new Date().toISOString(),\n    ai_model: 'gpt-4o-mini',\n    workflow_version: '2.0-url-based',\n    image_source: 'url'\n  };\n  \n  console.log(\"✓ Analysis validation complete\");\n  console.log(`Health Score: ${analysis.summary.overall_health_score}/10`);\n  console.log(`Primary Concern: ${analysis.summary.primary_concern}`);\n  \n} catch (error) {\n  console.error('❌ Parse/Validation error:', error.message);\n  \n  // Return structured error response with ALL preserved fields (UNCHANGED structure)\n  analysis = {\n    error: true,\n    error_message: error.message,\n    error_type: 'parsing_error',\n    raw_output_sample: agentOutput.substring(0, 500),\n    \n    // PRESERVE ALL INPUT FIELDS\n    ...preservedFields,\n    \n    // Default error structures (UNCHANGED from original)\n    plant_identification: {\n      species: \"Error - Unable to analyze\",\n      variety: \"unknown\",\n      growth_stage: \"unknown\",\n      confidence: 0,\n      identifying_features: [],\n      visible_parts: []\n    },\n    health_assessment: {\n      vigor_score: 0,\n      leaf_color: \"Unable to analyze due to error\",\n      leaf_texture: \"Unable to analyze due to error\",\n      growth_pattern: \"Unable to analyze due to error\",\n      structural_integrity: \"Unable to analyze due to error\",\n      stress_indicators: [],\n      disease_symptoms: [],\n      severity: \"unknown\"\n    },\n    nutrient_status: {\n      nitrogen: \"unknown\",\n      phosphorus: \"unknown\",\n      potassium: \"unknown\",\n      calcium: \"unknown\",\n      magnesium: \"unknown\",\n      iron: \"unknown\",\n      primary_deficiency: \"Unable to determine\",\n      secondary_deficiencies: [],\n      severity: \"unknown\"\n    },\n    pest_disease: {\n      pests_detected: [],\n      diseases_detected: [],\n      damage_pattern: \"Unable to analyze due to error\",\n      affected_area_percentage: 0,\n      spread_risk: \"unknown\",\n      primary_issue: \"Unable to determine\"\n    },\n    environmental_stress: {\n      water_status: \"unknown\",\n      temperature_stress: \"unknown\",\n      light_stress: \"unknown\",\n      physical_damage: \"unknown\",\n      chemical_damage: \"unknown\",\n      soil_indicators: \"Unable to analyze due to error\",\n      primary_stressor: \"Unable to determine\"\n    },\n    cross_factor_insights: [],\n    recommendations: {\n      immediate: [\n        {\n          action: \"Manual inspection required\",\n          details: \"Automated analysis encountered an error. Please have an agricultural expert manually inspect the plant.\",\n          timeline: \"As soon as possible\",\n          priority: \"critical\"\n        }\n      ],\n      short_term: [],\n      preventive: [],\n      monitoring: []\n    },\n    summary: {\n      overall_health_score: 0,\n      primary_concern: \"Analysis failed - manual review required\",\n      secondary_concerns: [\"System error occurred\"],\n      critical_issues_count: 0,\n      confidence_level: 0,\n      prognosis: \"unknown\",\n      estimated_yield_impact: \"unknown\"\n    },\n    processing_metadata: {\n      parse_success: false,\n      processing_timestamp: new Date().toISOString(),\n      ai_model: 'gpt-4o-mini',\n      workflow_version: '2.0-url-based',\n      image_source: 'url',\n      error_details: error.toString()\n    }\n  };\n}\n\nconsole.log('=== FINAL PARSE OUTPUT CHECK =======================');\nconsole.log(`Farmer ID in final output: ${analysis.farmer_id}`);\nconsole.log(`Sponsor ID in final output: ${analysis.sponsor_id}`);\nconsole.log(`GPS Coordinates in final output: ${JSON.stringify(analysis.gps_coordinates)}`);\nconsole.log('================================================');\n\nreturn { \n  json: analysis\n};"
      },
      "id": "af5b156f-81b2-4a95-a17a-a11c4589476d",
      "name": "Parse and Validate Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -576,
        80
      ]
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// PARSE AND VALIDATE AI AGENT OUTPUT - MULTI-IMAGE VERSION\n// Output structure remains EXACTLY the same as original\n// ============================================\n\nconst item = $input.first();\n\n// FIRST PRESERVE ALL INPUT FIELDS (UNCHANGED)\nconst preservedFields = {\n  analysis_id: item.json.analysis_id,\n  timestamp: item.json.timestamp,\n  farmer_id: item.json.farmer_id,\n  sponsor_id: item.json.sponsor_id,\n  location: item.json.location,\n  gps_coordinates: item.json.gps_coordinates,\n  altitude: item.json.altitude,\n  field_id: item.json.field_id,\n  crop_type: item.json.crop_type,\n  planting_date: item.json.planting_date,\n  expected_harvest_date: item.json.expected_harvest_date,\n  last_fertilization: item.json.last_fertilization,\n  last_irrigation: item.json.last_irrigation,\n  previous_treatments: item.json.previous_treatments,\n  weather_conditions: item.json.weather_conditions,\n  temperature: item.json.temperature,\n  humidity: item.json.humidity,\n  soil_type: item.json.soil_type,\n  urgency_level: item.json.urgency_level,\n  notes: item.json.notes,\n  contact_info: item.json.contact_info,\n  additional_info: item.json.additional_info,\n  image_url: item.json.image_url,\n  image_metadata: item.json.image_metadata,\n  request_metadata: item.json.request_metadata,\n  rabbitmq_metadata: item.json.rabbitmq_metadata,\n  token_usage: item.json.token_usage\n};\n\nconsole.log('=== PARSE NODE - PRESERVED FIELDS ==================');\nconsole.log(`Farmer ID: ${preservedFields.farmer_id}`);\nconsole.log(`Sponsor ID: ${preservedFields.sponsor_id}`);\nconsole.log(`Total Images: ${preservedFields.image_metadata?.total_images || 1}`);\n\nconst agentOutput = item.json.output || item.json.response || item.json.content || item.json.text || item.json.message || \"\";\n\nconsole.log(\"Raw output length:\", agentOutput.length);\nconsole.log(\"Output type:\", typeof agentOutput);\n\nlet analysis;\nlet parseSuccess = false;\n\ntry {\n  // Try to parse JSON from agent output\n  if (typeof agentOutput === 'string') {\n    let cleanedOutput = agentOutput;\n    cleanedOutput = cleanedOutput.replace(/```json\\n?/g, '');\n    cleanedOutput = cleanedOutput.replace(/```\\n?/g, '');\n    \n    const jsonStart = cleanedOutput.indexOf('{');\n    const jsonEnd = cleanedOutput.lastIndexOf('}') + 1;\n    \n    if (jsonStart !== -1 && jsonEnd !== 0) {\n      const jsonStr = cleanedOutput.substring(jsonStart, jsonEnd);\n      console.log(\"Extracted JSON length:\", jsonStr.length);\n      analysis = JSON.parse(jsonStr);\n      parseSuccess = true;\n      console.log(\"✓ JSON parsed successfully\");\n    } else {\n      throw new Error('No JSON structure found in response');\n    }\n  } else if (typeof agentOutput === 'object' && agentOutput !== null) {\n    analysis = agentOutput;\n    parseSuccess = true;\n    console.log(\"✓ Response already in object format\");\n  } else {\n    throw new Error('Invalid response format from AI agent');\n  }\n  \n  // MERGE WITH PRESERVED FIELDS - THIS IS CRITICAL\n  analysis = {\n    ...analysis,           // AI analysis results\n    ...preservedFields     // Override with all preserved fields\n  };\n  \n  // Validate required sections exist (UNCHANGED structure)\n  const requiredSections = [\n    'plant_identification',\n    'health_assessment',\n    'nutrient_status',\n    'pest_disease',\n    'environmental_stress',\n    'recommendations',\n    'summary'\n  ];\n  \n  for (const section of requiredSections) {\n    if (!analysis[section]) {\n      console.warn(`⚠ Missing section: ${section}, adding default`);\n      // Add default structures (UNCHANGED from original)\n      switch(section) {\n        case 'plant_identification':\n          analysis[section] = {\n            species: \"Unable to identify\",\n            variety: \"unknown\",\n            growth_stage: \"unknown\",\n            confidence: 0,\n            identifying_features: [],\n            visible_parts: []\n          };\n          break;\n        case 'health_assessment':\n          analysis[section] = {\n            vigor_score: 5,\n            leaf_color: \"Not analyzed\",\n            leaf_texture: \"Not analyzed\",\n            growth_pattern: \"Not analyzed\",\n            structural_integrity: \"Not analyzed\",\n            stress_indicators: [],\n            disease_symptoms: [],\n            severity: \"unknown\"\n          };\n          break;\n        case 'nutrient_status':\n          analysis[section] = {\n            nitrogen: \"unknown\",\n            phosphorus: \"unknown\",\n            potassium: \"unknown\",\n            calcium: \"unknown\",\n            magnesium: \"unknown\",\n            iron: \"unknown\",\n            primary_deficiency: \"none\",\n            secondary_deficiencies: [],\n            severity: \"unknown\"\n          };\n          break;\n        case 'pest_disease':\n          analysis[section] = {\n            pests_detected: [],\n            diseases_detected: [],\n            damage_pattern: \"Not analyzed\",\n            affected_area_percentage: 0,\n            spread_risk: \"unknown\",\n            primary_issue: \"none\"\n          };\n          break;\n        case 'environmental_stress':\n          analysis[section] = {\n            water_status: \"unknown\",\n            temperature_stress: \"unknown\",\n            light_stress: \"unknown\",\n            physical_damage: \"unknown\",\n            chemical_damage: \"unknown\",\n            soil_indicators: \"Not analyzed\",\n            primary_stressor: \"none\"\n          };\n          break;\n        case 'recommendations':\n          analysis[section] = {\n            immediate: [],\n            short_term: [],\n            preventive: [],\n            monitoring: []\n          };\n          break;\n        case 'summary':\n          analysis[section] = {\n            overall_health_score: 5,\n            primary_concern: \"Analysis incomplete\",\n            secondary_concerns: [],\n            critical_issues_count: 0,\n            confidence_level: 0,\n            prognosis: \"unknown\",\n            estimated_yield_impact: \"unknown\"\n          };\n          break;\n      }\n    }\n  }\n  \n  // Ensure arrays exist\n  analysis.cross_factor_insights = analysis.cross_factor_insights || [];\n  \n  // Add processing metadata (UNCHANGED structure)\n  analysis.processing_metadata = {\n    parse_success: parseSuccess,\n    processing_timestamp: new Date().toISOString(),\n    ai_model: 'gpt-4o-mini',\n    workflow_version: '2.0-url-based',\n    image_source: 'url'\n  };\n  \n  console.log(\"✓ Analysis validation complete\");\n  console.log(`Health Score: ${analysis.summary.overall_health_score}/10`);\n  console.log(`Primary Concern: ${analysis.summary.primary_concern}`);\n  \n} catch (error) {\n  console.error('❌ Parse/Validation error:', error.message);\n  \n  // Return structured error response with ALL preserved fields (UNCHANGED structure)\n  analysis = {\n    error: true,\n    error_message: error.message,\n    error_type: 'parsing_error',\n    raw_output_sample: agentOutput.substring(0, 500),\n    \n    // PRESERVE ALL INPUT FIELDS\n    ...preservedFields,\n    \n    // Default error structures (UNCHANGED from original)\n    plant_identification: {\n      species: \"Error - Unable to analyze\",\n      variety: \"unknown\",\n      growth_stage: \"unknown\",\n      confidence: 0,\n      identifying_features: [],\n      visible_parts: []\n    },\n    health_assessment: {\n      vigor_score: 0,\n      leaf_color: \"Unable to analyze due to error\",\n      leaf_texture: \"Unable to analyze due to error\",\n      growth_pattern: \"Unable to analyze due to error\",\n      structural_integrity: \"Unable to analyze due to error\",\n      stress_indicators: [],\n      disease_symptoms: [],\n      severity: \"unknown\"\n    },\n    nutrient_status: {\n      nitrogen: \"unknown\",\n      phosphorus: \"unknown\",\n      potassium: \"unknown\",\n      calcium: \"unknown\",\n      magnesium: \"unknown\",\n      iron: \"unknown\",\n      primary_deficiency: \"Unable to determine\",\n      secondary_deficiencies: [],\n      severity: \"unknown\"\n    },\n    pest_disease: {\n      pests_detected: [],\n      diseases_detected: [],\n      damage_pattern: \"Unable to analyze due to error\",\n      affected_area_percentage: 0,\n      spread_risk: \"unknown\",\n      primary_issue: \"Unable to determine\"\n    },\n    environmental_stress: {\n      water_status: \"unknown\",\n      temperature_stress: \"unknown\",\n      light_stress: \"unknown\",\n      physical_damage: \"unknown\",\n      chemical_damage: \"unknown\",\n      soil_indicators: \"Unable to analyze due to error\",\n      primary_stressor: \"Unable to determine\"\n    },\n    cross_factor_insights: [],\n    recommendations: {\n      immediate: [\n        {\n          action: \"Manual inspection required\",\n          details: \"Automated analysis encountered an error. Please have an agricultural expert manually inspect the plant.\",\n          timeline: \"As soon as possible\",\n          priority: \"critical\"\n        }\n      ],\n      short_term: [],\n      preventive: [],\n      monitoring: []\n    },\n    summary: {\n      overall_health_score: 0,\n      primary_concern: \"Analysis failed - manual review required\",\n      secondary_concerns: [\"System error occurred\"],\n      critical_issues_count: 0,\n      confidence_level: 0,\n      prognosis: \"unknown\",\n      estimated_yield_impact: \"unknown\"\n    },\n    processing_metadata: {\n      parse_success: false,\n      processing_timestamp: new Date().toISOString(),\n      ai_model: 'gpt-4o-mini',\n      workflow_version: '2.0-url-based',\n      image_source: 'url',\n      error_details: error.toString()\n    }\n  };\n}\n\nconsole.log('=== FINAL PARSE OUTPUT CHECK =======================');\nconsole.log(`Farmer ID in final output: ${analysis.farmer_id}`);\nconsole.log(`Sponsor ID in final output: ${analysis.sponsor_id}`);\nconsole.log('================================================');\n\nreturn { \n  json: analysis\n};"
      },
      "id": "bfe6dfc6-2294-4f23-b6d8-863317cff143",
      "name": "Parse and Validate Analysis1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -496,
        432
      ],
      "disabled": true
    }
  ],
  "pinData": {},
  "connections": {
    "RabbitMQ Trigger": {
      "main": [
        [
          {
            "node": "Parse and Validate RabbitMQ Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse and Validate RabbitMQ Message": {
      "main": [
        [
          {
            "node": "Agricultural Analysis AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agricultural Analysis AI Agent": {
      "main": [
        [
          {
            "node": "Token Usage Calculator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if Failed": {
      "main": [
        [
          {
            "node": "Send to DLQ",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI GPT-5-mini": {
      "ai_languageModel": [
        [
          {
            "node": "Agricultural Analysis AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Token Usage Calculator": {
      "main": [
        [
          {
            "node": "Parse and Validate Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse and Validate Analysis": {
      "main": [
        [
          {
            "node": "Send to Response Queue",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Response Queue": {
      "main": [
        [
          {
            "node": "Check if Failed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "fa4db664-f740-4749-8089-3dce02bbd06a",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "acd8ed575a05e6298637099619e6ee2cbd2c697a65f3a64afce17dae956da44e"
  },
  "id": "XpiRVhtE6SwWc0fN",
  "tags": []
}